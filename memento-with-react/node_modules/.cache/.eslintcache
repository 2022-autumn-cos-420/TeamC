[{"/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/reportWebVitals.js":"1","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/index.tsx":"2","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/App.tsx":"3","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/utils.ts":"4","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/CollectPage.tsx":"5","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/HomePage.tsx":"6","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/QuizPage.tsx":"7","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/ImportPage.tsx":"8","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/components/Colltab.tsx":"9","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/components/Flashcard.tsx":"10","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/components/Parsecard.tsx":"11","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/components/Importcard.tsx":"12","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/importExport.ts":"13","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/components/Exportcard.tsx":"14"},{"size":362,"mtime":1669577634388,"results":"15","hashOfConfig":"16"},{"size":901,"mtime":1669583425250,"results":"17","hashOfConfig":"16"},{"size":7079,"mtime":1669746520921,"results":"18","hashOfConfig":"16"},{"size":1927,"mtime":1669628296846,"results":"19","hashOfConfig":"16"},{"size":6552,"mtime":1669749546865,"results":"20","hashOfConfig":"16"},{"size":3605,"mtime":1669596723510,"results":"21","hashOfConfig":"16"},{"size":1130,"mtime":1669597075551,"results":"22","hashOfConfig":"16"},{"size":569,"mtime":1669733633577,"results":"23","hashOfConfig":"16"},{"size":4196,"mtime":1669639204594,"results":"24","hashOfConfig":"16"},{"size":5014,"mtime":1669596934334,"results":"25","hashOfConfig":"16"},{"size":981,"mtime":1669590396020,"results":"26","hashOfConfig":"16"},{"size":3492,"mtime":1669740702184,"results":"27","hashOfConfig":"16"},{"size":8062,"mtime":1669746673767,"results":"28","hashOfConfig":"16"},{"size":1488,"mtime":1669749271001,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"33"},"sygvsk",{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"37"},{"filePath":"38","messages":"39","suppressedMessages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"41","messages":"42","suppressedMessages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"37"},{"filePath":"45","messages":"46","suppressedMessages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"48","messages":"49","suppressedMessages":"50","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"37"},{"filePath":"52","messages":"53","suppressedMessages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"37"},{"filePath":"56","messages":"57","suppressedMessages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"37"},{"filePath":"60","messages":"61","suppressedMessages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"37"},{"filePath":"64","messages":"65","suppressedMessages":"66","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"37"},{"filePath":"68","messages":"69","suppressedMessages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"37"},{"filePath":"71","messages":"72","suppressedMessages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74","usedDeprecatedRules":"37"},{"filePath":"75","messages":"76","suppressedMessages":"77","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"78","usedDeprecatedRules":"37"},{"filePath":"79","messages":"80","suppressedMessages":"81","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/reportWebVitals.js",[],[],[],"/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/index.tsx",[],[],[],"/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/App.tsx",["82","83","84","85","86","87","88","89"],[],"/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/utils.ts",["90","91","92","93","94","95"],[],"import { urlToHttpOptions } from \"url\";\nimport { Card } from \"./interfaces/card\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { equal } from \"assert\";\n\nexport const exportPath: string = \"./exportedCards/\";\n\nexport function arrayEquality(arrayOne: string[], arrayTwo: string[]): boolean {\n    if (arrayOne.length !== arrayTwo.length) {\n        return false;\n    };\n    let isEqual = true;\n    arrayOne.map((string: string, index: number): void => {\n        if (string !== arrayTwo[index]) {\n            isEqual = false;\n        }\n    });\n    return isEqual;\n}\n\nexport function cardEquality(cardOne: Card, cardTwo: Card): boolean {\n    const isEqual: boolean =\n        cardOne.frontText === cardTwo.frontText &&\n        cardOne.backText === cardTwo.backText &&\n        arrayEquality(cardOne.cardDecks, cardTwo.cardDecks) &&\n        cardOne.cardHint === cardTwo.cardHint &&\n        cardOne.cardColor === cardTwo.cardColor &&\n        cardOne.accuracy === cardTwo.accuracy;\n    return isEqual;\n}\n\nexport function deckEquality(deckOne: Card[], deckTwo: Card[]): boolean {\n    let isEqual: boolean = true;\n    if (deckOne.length === 0 || deckOne.length !== deckTwo.length){\n        isEqual = false;\n    }\n    else {\n        deckOne.map((card: Card, index: number): void => {\n            if (cardEquality(card, deckTwo[index]) !== true) {\n                isEqual = false;\n            }\n        });\n    }\n    return isEqual;\n}\n\n\nexport function stringToCard(string: string): Card {\n    const cardArray: string[] = string.split(\"<|>\")\n    const card: Card = {\n        // The ID of imported cards needs to be assigned at the time of import based on the collection\n        id: -1,\n        cardColor: cardArray[0],\n        frontText: cardArray[1],\n        backText: cardArray[2],\n        cardHint: cardArray[3],\n        cardDecks: cardArray[4].split(\",\"),\n        accuracy: Number(cardArray[5])\n    }\n    return card;\n}  ","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/CollectPage.tsx",["96","97","98","99","100"],[],"/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/HomePage.tsx",["101"],[],"import React, {useState, Component} from \"react\";\nimport './HomePage.css';\nimport FlashCard from './components/Flashcard'\nimport ParseCard from './components/Parsecard'\n\n// class App extends React.Component<{ message: string }, { count: number }> {\n//     state = { count: 0 };\n//     render() {\n//       return (\n//         <div onClick={() => this.increment(1)}>\n//           {this.props.message} {this.state.count}\n//         </div>\n//       );\n//     }\n//     increment = (amt: number) => {\n//       // like this\n//       this.setState((state) => ({\n//         count: state.count + amt,\n//       }));\n//     };\n//   }\n\ninterface Props {\n    cardType: string;\n    addCard: (cFrontText: string, cBackText: string, cCardHint: string, cCardDeck: string) => void;\n};\ninterface State {\n    cardType: string,\n    frontText: string,\n    backText: string,\n    cardHint: string,\n    cardDeck: string,\n    addCard: (cFrontText: string, cBackText: string, cCardHint: string, cCardDeck: string) => void\n};\n\nclass HomePage extends Component<Props, State> {\n\n    constructor(props: Props) {\n        super(props)\n        this.state = {\n            cardType: \"FlashCard\",\n            frontText: \"\",\n            backText: \"\",\n            cardHint: \"\",\n            cardDeck: \"\",\n            addCard: this.props.addCard\n        }\n        this.toggleCardType = this.toggleCardType.bind(this);\n    }\n    \n\n    updateHandler = (newFront: string, newBack: string, newHint: string, newDeck: string): void => {\n        console.log(\"updating!\");\n        this.setState({frontText: newFront,\n                        backText: newBack,\n                        cardHint: newHint,\n                        cardDeck: newDeck});\n    }\n\n    addCardHandler = (event: MouseEvent): void => {\n        this.setState({frontText: \"\",\n                        backText: \"\",\n                        cardHint: \"\",\n                        cardDeck: \"\"}, () => {console.log(\"New HomePage state frontText: \", this.state.frontText)});\n                    \n        //Now we have to call the page above, to app.js\n        console.log(\"Trying to add Card! in HomePage, got: \", this.state.frontText, \"Back: \", this.state.backText);\n        //! Changed newDeckArray to be a string, assuming that the user only adds new cards to at most 1 deck\n        let newDeckArray = this.state.cardDeck;\n        this.props.addCard(this.state.frontText, this.state.backText, this.state.cardHint, newDeckArray)\n    }\n\n    toggleCardType = () => {\n        if (this.state.cardType ===\"FlashCard\") {\n            this.setState({cardType: \"ParseCard\"});\n        }\n        else {\n            this.setState({cardType: \"FlashCard\"});\n        }\n        console.log(\"Toggling Card!\");\n    }\n\n    render() {\n        return (\n            <div>\n                {this.state.cardType === \"FlashCard\" && <FlashCard type={\"Normal\"} frontText={this.state.frontText} backText={this.state.backText} cardHint={this.state.cardHint} cardDeck={this.state.cardDeck} update = {this.updateHandler}></FlashCard>}\n                {this.state.cardType === \"ParseCard\" && <ParseCard cardDeck={this.state.cardDeck}></ParseCard>}\n                <div className=\"HomeCardButtons\">\n                    <label className=\"Switch\">\n                        <input type=\"checkbox\"></input>\n                        <span className = \"slider round\" onClick={() => this.toggleCardType}></span>\n                    </label>\n                    <button className=\"AddCardButton\" onClick={() => this.addCardHandler}>&#43;</button>\n                </div>\n            </div>\n\n\n        )\n    }\n}\n\nexport default HomePage;","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/QuizPage.tsx",["102","103","104","105","106","107","108"],[],"import React, {useState, Component} from \"react\";\nimport './QuizPage.css';\nimport FlashCard from './components/Flashcard'\nimport { Card } from \"../interfaces/card\";\nimport { cardEquality, arrayEquality, exportPath, deckEquality, stringToCard } from \"../utils\";\n\ninterface Props {\n    cardArray: Card[];\n}\ninterface State {\n    cardArray: Card[],\n    frontText: string,\n    backText: string,\n    cardHint: string,\n    cardDecks: string[],\n    cardType: string\n}\nclass QuizPage extends Component<Props, State> {\n    constructor(props: Props) {\n        super(props)\n        this.state = {\n            cardArray: this.props.cardArray,\n            frontText: \"\",\n            backText: \"\",\n            cardHint: \"\",\n            cardDecks: [],\n            cardType: \"QuizCard\",\n        }\n    }\n\n    nextCard = () => {\n        \n    }\n\n    render() {\n        return (\n            <div>\n                {/* <FlashCard type={\"Quiz\"} frontText={this.state.frontText} backText={this.state.backText} cardHint={this.state.cardHint} cardDecks={this.state.cardDecks}></FlashCard> */}\n            </div>\n        )\n    }\n}\n\nexport default QuizPage;\n","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/ImportPage.tsx",["109","110"],[],"import React, {useState, Component} from \"react\";\n/*import './ImportPage.css';*/\nimport ImportCard from './components/Importcard';\n// import { FileUploadField } from './components/Importcard';\n\ninterface Props {\n}\ninterface State {\n}\nclass ImportPage extends Component<Props, State> {\n    constructor(props: Props) {\n        super(props)\n        this.state = {\n\n        }\n    }\n\n    render() {\n        return (\n            <div className= \"importPage\">\n                {/* <ImportCard preview={\"\"} /> */}\n            </div>\n        )\n    }\n}\n\nexport default ImportPage;","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/components/Colltab.tsx",["111","112","113","114","115","116"],[],"import React, {Component} from 'react';\nimport './Colltab.css';\nimport * as fs from \"fs\";\nimport { Card } from \"../../interfaces/card\";\nimport { cardEquality, arrayEquality, exportPath, deckEquality, stringToCard } from \"../../utils\";\n\ninterface Props {\n    card: Card,\n    deleted: (targetCard: Card) => void,\n    updated: (oldCard: Card, newFront: string, newBack: string, newHint:string, newDecks: string[]) => void\n}\ninterface State {\n    render: boolean,\n    localCard: Card\n}\nclass CollTab extends Component<Props, State>{    //Still need to figure out how to pass changes up from the tab!\n    constructor(props: Props) {\n        super(props)\n        this.state = {\n            render: false,\n            localCard: this.props.card\n        }\n        this.toggleContent = this.toggleContent.bind(this);\n    }\n\n\n    toggleContent() { //This currently works although it is quite ugly and doesn't do any animation\n        this.setState({render: !this.state.render});\n        console.log(\"Changing the render!\", this.state.render);\n    }\n\n    handleFrontChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        this.setState({localCard: {...this.state.localCard, frontText: event.currentTarget.value}});\n    }\n\n    handleBackChange = (event:  React.ChangeEvent<HTMLInputElement>) => {\n        this.setState({localCard: {...this.state.localCard, backText: event.currentTarget.value}});\n    }\n\n    handleHintChange = (event:  React.ChangeEvent<HTMLInputElement>) => {\n        this.setState({localCard: {...this.state.localCard, cardHint: event.currentTarget.value}});\n    }\n    \n    handleDecksChange = (event:  React.ChangeEvent<HTMLInputElement>) => {\n        this.setState({localCard: {...this.state.localCard, cardDecks: [event.currentTarget.value]}});\n    }\n\n\n    render() {\n        const buttonStyle = {\n            backgroundColor: 'white',\n            font: 'inherit',\n            border: '1px solid blue',\n            padding: '8px',\n            cursor: 'pointer'\n        };\n    return (\n        <div className=\"CollTab\">\n            <button type=\"button\" onClick={this.toggleContent} className='collapsible'>{this.state.localCard.frontText}</button>\n            <div \n                className=\"content\"\n                style={{maxHeight: this.state.render ? '400px': '0px'}}>\n                <div className=\"row\">\n                    <div className=\"column\">\n                        {/* <h>Current Card Values:</h> */}\n                        <p>Current Card Values:</p>\n                        <p>Front Text: {this.props.card.frontText}</p>\n                        <p>Back Text: {this.props.card.backText}</p>\n                        <p>Card Hint: {this.props.card.cardHint} </p>\n                        <p>Card Decks: {this.props.card.cardDecks}</p>\n                    </div>\n                    <div className=\"column\">\n                        <p>Please enter new values:</p>\n                        {/* <h>Please enter new values:</h> */}\n                        <p><input type=\"text\" onChange={this.handleFrontChange} value={this.state.localCard.frontText}></input></p>\n                        <p><input type=\"text\" onChange={this.handleBackChange} value={this.state.localCard.backText}></input></p>\n                        <p><input type=\"text\" onChange={this.handleHintChange} value={this.state.localCard.cardHint}></input></p>\n                        <p><input type=\"text\" onChange={this.handleDecksChange} value={this.state.localCard.cardDecks}></input></p>\n                    </div>\n                </div>\n                <div className=\"CollTabButtons\">\n                    <button\n                        style={buttonStyle}\n                        onClick={() => this.props.updated(this.props.card, this.state.localCard.frontText, this.state.localCard.backText, this.state.localCard.cardHint, this.state.localCard.cardDecks)}>Update Card</button>\n                    <button\n                        className=\"deleteButton\"\n                        style={buttonStyle}\n                        onClick={() => this.props.deleted(this.props.card)}>Delete Card</button>\n                </div>\n            </div>\n        </div>\n    )\n    }\n};\n\nexport default CollTab;","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/components/Flashcard.tsx",["117","118"],[],"import React, {ChangeEvent, Component, PropsWithChildren} from 'react';\nimport './Flashcard.css';\n\ninterface Props {\n    type: string,\n    frontText: string,\n    backText: string,\n    cardHint: string,\n    cardDeck: string,\n    update: (newFront: string, newBack: string, newHint: string, newDeck: string) => void\n};\ninterface State {\n    side: string,\n    type: string,\n    localCardFront: string,\n    localCardBack: string,\n    localcardDeck: string,\n    localCardHint: string,\n    flipState: boolean\n};\n\n\nclass FlashCard extends Component<Props, State> {\n    constructor(props: Props) {\n        super(props)\n        this.state = {\n            side: \"front\",\n            type: this.props.type,\n            localCardFront: this.props.frontText,\n            localCardBack: this.props.backText,\n            localcardDeck: this.props.cardDeck,\n            localCardHint: this.props.cardHint,\n            flipState: false\n        }\n        this.flipCard = this.flipCard.bind(this);\n    }\n\n    flipCard = () => {\n        console.log(\"Flipping from: \", this.state.side);\n        this.setState({flipState: !this.state.flipState});\n        if (this.state.side === \"front\") {\n            this.setState({side: \"back\"});\n        }\n        else {\n            this.setState({side: \"front\"});\n        }\n        console.log(\"flipState:\", this.state.flipState);\n        console.log(this.state.localCardFront);\n    }\n\n    handleFrontChange = (event:  React.ChangeEvent<HTMLInputElement>) => {\n        if (this.props.type !== \"Normal\") {\n            return;\n        }\n        console.log(\"Changing the front!\");\n        let newFront = event.currentTarget.value;\n        this.setState({localCardFront: newFront});\n        console.log(\"NewState for front: \", newFront);\n        this.props.update(newFront, this.state.localCardBack, this.state.localCardHint, this.state.localcardDeck);\n\n    }\n\n    handleBackChange = (event:  React.ChangeEvent<HTMLInputElement>) => {\n        if (this.props.type !== \"Normal\") {\n            return;\n        }\n        let newBack = event.currentTarget.value;\n        this.setState({localCardBack: newBack});\n        this.props.update(this.state.localCardFront, newBack, this.state.localCardHint, this.state.localcardDeck);\n\n    }\n\n    handleHintChange = (event:  React.ChangeEvent<HTMLInputElement>) => {\n        if (this.props.type !== \"Normal\") {\n            return;\n        }\n        let newHint = event.currentTarget.value;\n        this.setState({localCardHint: newHint});\n        this.props.update(this.state.localCardFront, this.state.localCardBack, newHint, this.state.localcardDeck);\n\n    }\n\n    handleDecksChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        if (this.props.type !== \"Normal\") {\n            return;\n        }\n        let newDecks = event.currentTarget.value;\n        this.setState({localcardDeck: newDecks});\n        this.props.update(this.state.localCardFront, this.state.localCardBack, this.state.localCardHint, newDecks);\n    }\n\n\n    render() {\n        return (\n            <div className=\"FlashCard\">\n                <div className=\"FlashCardInner\" style={{transform: this.state.flipState ? \"rotateX(180deg)\": \"\"}}>\n                    <div className=\"FlashCardFront\">\n                        {/* <top> */}\n                        <ul>\n                            <li><span className=\"Dot\"></span></li>\n                            <li><input type=\"CardHint\" placeholder=\"Notes/Hints\" onChange={this.handleHintChange} value={this.props.cardHint} style={{opacity: this.props.type === \"Quiz\" ? \"0\": \"1\"}}></input></li>\n                            <li><input type=\"CardDeck\" placeholder=\"Deck\" onChange={this.handleDecksChange} className=\"CardDeck\" value={this.props.cardDeck}></input></li>\n                        </ul>\n                        {/* </top> */}\n                        <input type=\"CardFrontText\" placeholder=\"Write\" onChange = {this.handleFrontChange} value={this.props.frontText}></input>\n                        <button className=\"FlipCardButton\" onClick={this.flipCard}></button>\n                    </div>\n                    <div className=\"FlashCardBack\">\n                        {/* <top> */}\n                        <ul>\n                            <li><span className=\"Dot\"></span></li>\n                            <li><input type=\"CardHint\" placeholder=\"Notes/Hints\" onChange={this.handleHintChange} value={this.props.cardHint}></input></li>\n                            <li><input type=\"CardDeck\" placeholder=\"Deck\" onChange={this.handleDecksChange} className=\"CardDeck\" value={this.props.cardDeck}></input></li>\n                        </ul>\n                        {/* </top> */}\n                        <input type=\"CardFrontText\" placeholder=\"Write Back\" onChange = {this.handleBackChange} value={this.props.backText}></input>\n                        <button className=\"FlipCardButton\" onClick={this.flipCard}></button>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n\n}\nexport default FlashCard","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/components/Parsecard.tsx",[],[],"/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/components/Importcard.tsx",["119","120","121","122","123","124","125"],[],"import React, {Component, ReactElement, useCallback, useState, ChangeEvent} from 'react';\nimport './Importcard.css';\nimport { Card } from \"../../interfaces/card\";\nimport { equal } from \"assert\";\nimport { exportCards, importCards } from '../../importExport';\n\ninterface Props {\n    collection: Card[],\n    parseInputs: (textInput: string, currentCollection: Card[], deckName: string) => Card[],\n    updateCollection: (childCollection: Card[]) => void\n}\ninterface State {\n    dragActive: boolean,\n    collection: Card[]\n}\nclass ImportCard extends Component<Props, State> {\n    constructor(props: Props) {\n        super(props)\n        this.state = {\n            dragActive: false,\n            collection: this.props.collection\n        }\n    };\n\n    // dragHandler = (event: React.DragEvent) => {\n    //     event.preventDefault();\n    //     event.stopPropagation();\n    //     if (event.type === \"dragenter\" || event.type === \"dragover\") {\n    //         this.setState({dragActive: true});\n    //     } else if (event.type === \"dragleave\") {\n    //         this.setState({dragActive: false});\n    //     }\n    // };\n\n    // dropHandler = (event: React.ChangeEvent) => {\n    //     event.preventDefault();\n    //     event.stopPropagation();\n    //     this.setState({dragActive: false});\n    //     // if (event.dataTransfer.files && event.dataTransfer.files[0]) {\n    //     //     //Handle files event.dataTransfer.files\n    //     //     console.log(\"File drop!\");\n    //     // }\n    // }\n\n\n    //Split this into its own function so that the function made by reader.onload can access \"this\" and its state\n    //  There might well be a cleaner way to do it though\n    readerChange(result: string) {\n        // console.log(\"Parsed state length: \" + this.props.parseInputs(result, this.state.collection, \"\").length);\n        this.setState({collection: this.props.parseInputs(result, this.state.collection, \"\")}, () => {\n            this.props.updateCollection(this.state.collection)\n        }\n        );\n        // console.log(\"Updated state length: \" + this.state.collection.length);\n    }\n\n    changeHandler = ( target: React.ChangeEvent<HTMLInputElement> ) => {\n        if (!target.currentTarget.files){\n            return\n        }\n        const reader = new FileReader();\n        reader.onload = () => {\n            if (reader.result) {\n                this.readerChange(reader.result as string)\n            }\n        };\n        // reader.addEventListener('load', (evt) => {\n        //     if (reader.result) {\n        //         this.setState({collection: this.props.parseInputs(reader.result as string, this.state.collection, \"\")});\n        //         console.log(\"ImportCard state length: \" + this.state.collection.length);\n        //         this.props.updateCollection(this.state.collection);\n        //     }\n        // });\n        reader.readAsText(target.currentTarget.files[0]);\n    };\n\n\n    render() {\n        return (\n            <div>\n                {/* <div className=\"ImportCard\">\n                    <form id=\"form-file-upload\" onDragEnter={() => this.dragHandler} onSubmit={() => {}}></form>\n                    <div>Eventually you will drag files here!</div>\n                </div> */}\n                <input data-testid=\"fileUpload\" type=\"file\" id=\"fileUpload\" onChange={this.changeHandler} />                \n                <div>\n                    {this.state.collection.length}\n                </div>\n            </div>\n        )\n    }\n}\nexport default ImportCard;","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/importExport.ts",["126","127","128","129","130","131","132","133","134","135","136"],[],"import { urlToHttpOptions } from \"url\";\nimport { Card } from \"./interfaces/card\";\nimport * as path from \"path\";\nimport { equal } from \"assert\";\nimport { cardEquality, arrayEquality, exportPath, deckEquality, stringToCard } from \"./utils\";\nconst fs = require('fs');\n\n\n\n// File management from tutorial: https://iq.opengenus.org/create-delete-files-directory-js/\n/***\nGoes over all cards in the users collection and exports them to a formatted txt file. \nThe user must provide a file name for the exported file.\nIf deckID is non-empty, then only cards included in the specified deck will be exported.\nReturns true on success and false on a failure\n */\nexport function exportCards(\n    cards: Card[],\n    fileName: string,\n    deckID: string = \"\"\n): boolean {\n    if (!fs.existsSync(exportPath)){\n        fs.mkdirSync(exportPath);\n    }\n    if (cards.length === 0) {\n        return false;\n    }\n    else if (deckID !== \"\"){\n        cards = cards.filter((card: Card): boolean => card.cardDecks.includes(deckID))\n        if (cards.length === 0) {\n            return false;\n        }    \n    }\n    let cardString: string = \"\";\n    let cardArray: string[] = [];\n    cards.map((card: Card): string[] => \n        // Results in growing string[] array where each string represents an array containing the data for one card object\n        // There are separate delimiters from join() between the properties of a given card (<|>) and between each card (<|||>)\n        // This way an array-of-arrays can be retrieved by a 2-step split() call and subsequently mapped over to recreate the cards.\n        cardArray = [...cardArray, [card.cardColor , card.frontText , card.backText , card.cardHint, card.cardDecks.join(\",\"), String(card.accuracy)].join(\"<|>\")],\n        );\n\n    cardString = cardArray.join(\"<|||>\")\n    // console.log(\"cardString is: \" + cardString + \"\\n\");\n\n    fs.writeFileSync((exportPath + fileName), cardString);\n \n    // fs.writeFileSync((exportPath + \"copyFile2.txt\"), cardString);\n    // fs.unlinkSync((exportPath + \"mytext.txt\"));\n    return true;\n}\n\n\n// File management from tutorial: https://iq.opengenus.org/create-delete-files-directory-js/\n/***\nGoes over all cards in the users collection and exports them to a formatted txt file. \nThe user must provide a file name for the exported file.\nIf deckID is non-empty, then only cards included in the specified deck will be exported.\nReturns true on success and false on a failure\n */\nexport function parseCardsToString(\n    cards: Card[],\n    deckID: string = \"\"\n): string {\n    console.log(cards.length);\n    if (cards.length === 0) {\n        return \"\";\n    }\n    else if (deckID !== \"\"){\n        cards = cards.filter((card: Card): boolean => card.cardDecks.includes(deckID))\n        if (cards.length === 0) {\n            return \"\";\n        }    \n    }\n    let cardString: string = \"\";\n    let cardArray: string[] = [];\n    cards.map((card: Card): string[] => \n        // Results in growing string[] array where each string represents an array containing the data for one card object\n        // There are separate delimiters from join() between the properties of a given card (<|>) and between each card (<|||>)\n        // This way an array-of-arrays can be retrieved by a 2-step split() call and subsequently mapped over to recreate the cards.\n        cardArray = [...cardArray, [card.cardColor , card.frontText , card.backText , card.cardHint, card.cardDecks.join(\",\"), String(card.accuracy)].join(\"<|>\")],\n        );\n    cardString = cardArray.join(\"<|||>\");\n    console.log(cardString);\n    return cardString;\n}\n\n\n\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * If deckName is specified, cards will only be added to the specified deck\n */\n export function loadCardsFromTxt(\n    filePath: string,\n    deckName: string = \"\"\n): Card[] {\n    const textFileString: string = fs.readFileSync(filePath).toString();\n    const importedIntermediateData: string[] = textFileString.split(\"<|||>\")\n    const importedCards: Card[] = importedIntermediateData.map((cardString: string): Card =>\n        stringToCard(cardString)\n    )\n    return importedCards;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * If deckName is specified, cards will only be added to the specified deck\n */\n export function loadCardsFromString(\n    inputText: string,\n    deckName: string = \"\"\n): Card[] {\n    const importedIntermediateData: string[] = inputText.split(\"<|||>\")\n    const importedCards: Card[] = importedIntermediateData.map((cardString: string): Card =>\n        stringToCard(cardString)\n    )\n    return importedCards;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * Missing Functionality: Once integrated with React UI:\n *       If deckName is specified, cards will be added to the specified deck\n */\n export function importCards(\n    filePath: string,\n    collection: Card[],\n    deckName: string = \"\"\n): Card[] {\n    let maxId = -1;\n    collection.map((card: Card): void => {\n        if (card.id > maxId){maxId = card.id}\n    })\n    const importedCards: Card[] = loadCardsFromTxt(filePath, deckName)\n    importedCards.map((card: Card): void => {\n        let duplicate: boolean = false;\n        if ( collection.length !== 0 ){\n            collection.map((collectionCard: Card): void => {\n                if (cardEquality(collectionCard, card)) {\n                    duplicate = true;\n                }\n            })\n            if (duplicate === false){\n                maxId = maxId + 1\n                collection = [...collection, { \n                    id: maxId, \n                    cardColor: card.cardColor, \n                    frontText: card.frontText, \n                    backText: card.backText, \n                    cardHint: card.cardHint, \n                    cardDecks: card.cardDecks, \n                    accuracy: card.accuracy }]\n            }\n        }\n        else {\n            maxId = maxId + 1\n            collection = [{ \n                id: maxId, \n                cardColor: card.cardColor, \n                frontText: card.frontText, \n                backText: card.backText, \n                cardHint: card.cardHint, \n                cardDecks: card.cardDecks, \n                accuracy: card.accuracy }]\n        }\n    })\n    return collection;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * Missing Functionality: Once integrated with React UI:\n *       If deckName is specified, cards will be added to the specified deck\n */\n export function parseInputs(\n    inputText: string,\n    collection: Card[],\n    deckName: string = \"\"\n): Card[] {\n    let maxId = -1;\n    collection.map((card: Card): void => {\n        if (card.id > maxId){maxId = card.id}\n    })\n    const importedCards: Card[] = loadCardsFromString(inputText, deckName)\n    importedCards.map((card: Card): void => {\n        let duplicate: boolean = false;\n        if ( collection.length !== 0 ){\n            collection.map((collectionCard: Card): void => {\n                if (cardEquality(collectionCard, card)) {\n                    duplicate = true;\n                }\n            })\n            if (duplicate === false){\n                maxId = maxId + 1\n                collection = [...collection, { \n                    id: maxId, \n                    cardColor: card.cardColor, \n                    frontText: card.frontText, \n                    backText: card.backText, \n                    cardHint: card.cardHint, \n                    cardDecks: card.cardDecks, \n                    accuracy: card.accuracy }]\n            }\n        }\n        else {\n            maxId = maxId + 1\n            collection = [{ \n                id: maxId, \n                cardColor: card.cardColor, \n                frontText: card.frontText, \n                backText: card.backText, \n                cardHint: card.cardHint, \n                cardDecks: card.cardDecks, \n                accuracy: card.accuracy }]\n        }\n    })\n    return collection;\n}\n\n\n","/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/pages/components/Exportcard.tsx",["137"],[],{"ruleId":"138","severity":1,"message":"139","line":9,"column":10,"nodeType":"140","messageId":"141","endLine":9,"endColumn":15},{"ruleId":"138","severity":1,"message":"142","line":10,"column":24,"nodeType":"140","messageId":"141","endLine":10,"endColumn":37},{"ruleId":"138","severity":1,"message":"143","line":10,"column":39,"nodeType":"140","messageId":"141","endLine":10,"endColumn":49},{"ruleId":"138","severity":1,"message":"144","line":10,"column":51,"nodeType":"140","messageId":"141","endLine":10,"endColumn":63},{"ruleId":"138","severity":1,"message":"145","line":10,"column":65,"nodeType":"140","messageId":"141","endLine":10,"endColumn":77},{"ruleId":"138","severity":1,"message":"146","line":11,"column":23,"nodeType":"140","messageId":"141","endLine":11,"endColumn":34},{"ruleId":"147","severity":1,"message":"148","line":39,"column":42,"nodeType":"149","messageId":"150","endLine":39,"endColumn":44},{"ruleId":"147","severity":1,"message":"148","line":61,"column":38,"nodeType":"149","messageId":"150","endLine":61,"endColumn":40},{"ruleId":"138","severity":1,"message":"151","line":1,"column":10,"nodeType":"140","messageId":"141","endLine":1,"endColumn":26},{"ruleId":"138","severity":1,"message":"152","line":3,"column":13,"nodeType":"140","messageId":"141","endLine":3,"endColumn":15},{"ruleId":"138","severity":1,"message":"153","line":4,"column":13,"nodeType":"140","messageId":"141","endLine":4,"endColumn":17},{"ruleId":"138","severity":1,"message":"139","line":5,"column":10,"nodeType":"140","messageId":"141","endLine":5,"endColumn":15},{"ruleId":"147","severity":1,"message":"148","line":14,"column":56,"nodeType":"149","messageId":"150","endLine":14,"endColumn":58},{"ruleId":"147","severity":1,"message":"148","line":39,"column":55,"nodeType":"149","messageId":"150","endLine":39,"endColumn":57},{"ruleId":"138","severity":1,"message":"154","line":1,"column":16,"nodeType":"140","messageId":"141","endLine":1,"endColumn":24},{"ruleId":"138","severity":1,"message":"142","line":7,"column":24,"nodeType":"140","messageId":"141","endLine":7,"endColumn":37},{"ruleId":"138","severity":1,"message":"143","line":7,"column":39,"nodeType":"140","messageId":"141","endLine":7,"endColumn":49},{"ruleId":"138","severity":1,"message":"144","line":7,"column":51,"nodeType":"140","messageId":"141","endLine":7,"endColumn":63},{"ruleId":"138","severity":1,"message":"145","line":7,"column":65,"nodeType":"140","messageId":"141","endLine":7,"endColumn":77},{"ruleId":"138","severity":1,"message":"154","line":1,"column":16,"nodeType":"140","messageId":"141","endLine":1,"endColumn":24},{"ruleId":"138","severity":1,"message":"154","line":1,"column":16,"nodeType":"140","messageId":"141","endLine":1,"endColumn":24},{"ruleId":"138","severity":1,"message":"155","line":3,"column":8,"nodeType":"140","messageId":"141","endLine":3,"endColumn":17},{"ruleId":"138","severity":1,"message":"156","line":5,"column":10,"nodeType":"140","messageId":"141","endLine":5,"endColumn":22},{"ruleId":"138","severity":1,"message":"142","line":5,"column":24,"nodeType":"140","messageId":"141","endLine":5,"endColumn":37},{"ruleId":"138","severity":1,"message":"143","line":5,"column":39,"nodeType":"140","messageId":"141","endLine":5,"endColumn":49},{"ruleId":"138","severity":1,"message":"144","line":5,"column":51,"nodeType":"140","messageId":"141","endLine":5,"endColumn":63},{"ruleId":"138","severity":1,"message":"145","line":5,"column":65,"nodeType":"140","messageId":"141","endLine":5,"endColumn":77},{"ruleId":"138","severity":1,"message":"154","line":1,"column":16,"nodeType":"140","messageId":"141","endLine":1,"endColumn":24},{"ruleId":"138","severity":1,"message":"157","line":3,"column":8,"nodeType":"140","messageId":"141","endLine":3,"endColumn":18},{"ruleId":"138","severity":1,"message":"152","line":3,"column":13,"nodeType":"140","messageId":"141","endLine":3,"endColumn":15},{"ruleId":"138","severity":1,"message":"156","line":5,"column":10,"nodeType":"140","messageId":"141","endLine":5,"endColumn":22},{"ruleId":"138","severity":1,"message":"142","line":5,"column":24,"nodeType":"140","messageId":"141","endLine":5,"endColumn":37},{"ruleId":"138","severity":1,"message":"143","line":5,"column":39,"nodeType":"140","messageId":"141","endLine":5,"endColumn":49},{"ruleId":"138","severity":1,"message":"144","line":5,"column":51,"nodeType":"140","messageId":"141","endLine":5,"endColumn":63},{"ruleId":"138","severity":1,"message":"145","line":5,"column":65,"nodeType":"140","messageId":"141","endLine":5,"endColumn":77},{"ruleId":"138","severity":1,"message":"158","line":1,"column":16,"nodeType":"140","messageId":"141","endLine":1,"endColumn":27},{"ruleId":"138","severity":1,"message":"159","line":1,"column":40,"nodeType":"140","messageId":"141","endLine":1,"endColumn":57},{"ruleId":"138","severity":1,"message":"160","line":1,"column":27,"nodeType":"140","messageId":"141","endLine":1,"endColumn":39},{"ruleId":"138","severity":1,"message":"161","line":1,"column":41,"nodeType":"140","messageId":"141","endLine":1,"endColumn":52},{"ruleId":"138","severity":1,"message":"154","line":1,"column":54,"nodeType":"140","messageId":"141","endLine":1,"endColumn":62},{"ruleId":"138","severity":1,"message":"158","line":1,"column":64,"nodeType":"140","messageId":"141","endLine":1,"endColumn":75},{"ruleId":"138","severity":1,"message":"139","line":4,"column":10,"nodeType":"140","messageId":"141","endLine":4,"endColumn":15},{"ruleId":"138","severity":1,"message":"162","line":5,"column":10,"nodeType":"140","messageId":"141","endLine":5,"endColumn":21},{"ruleId":"138","severity":1,"message":"146","line":5,"column":23,"nodeType":"140","messageId":"141","endLine":5,"endColumn":34},{"ruleId":"138","severity":1,"message":"151","line":1,"column":10,"nodeType":"140","messageId":"141","endLine":1,"endColumn":26},{"ruleId":"138","severity":1,"message":"153","line":3,"column":13,"nodeType":"140","messageId":"141","endLine":3,"endColumn":17},{"ruleId":"138","severity":1,"message":"139","line":4,"column":10,"nodeType":"140","messageId":"141","endLine":4,"endColumn":15},{"ruleId":"138","severity":1,"message":"142","line":5,"column":24,"nodeType":"140","messageId":"141","endLine":5,"endColumn":37},{"ruleId":"138","severity":1,"message":"144","line":5,"column":51,"nodeType":"140","messageId":"141","endLine":5,"endColumn":63},{"ruleId":"147","severity":1,"message":"148","line":133,"column":39,"nodeType":"149","messageId":"150","endLine":133,"endColumn":41},{"ruleId":"147","severity":1,"message":"148","line":137,"column":42,"nodeType":"149","messageId":"150","endLine":137,"endColumn":44},{"ruleId":"147","severity":1,"message":"148","line":140,"column":57,"nodeType":"149","messageId":"150","endLine":140,"endColumn":59},{"ruleId":"147","severity":1,"message":"148","line":183,"column":39,"nodeType":"149","messageId":"150","endLine":183,"endColumn":41},{"ruleId":"147","severity":1,"message":"148","line":187,"column":42,"nodeType":"149","messageId":"150","endLine":187,"endColumn":44},{"ruleId":"147","severity":1,"message":"148","line":190,"column":57,"nodeType":"149","messageId":"150","endLine":190,"endColumn":59},{"ruleId":"138","severity":1,"message":"163","line":3,"column":10,"nodeType":"140","messageId":"141","endLine":3,"endColumn":14},"@typescript-eslint/no-unused-vars","'equal' is defined but never used.","Identifier","unusedVar","'arrayEquality' is defined but never used.","'exportPath' is defined but never used.","'deckEquality' is defined but never used.","'stringToCard' is defined but never used.","'importCards' is defined but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'urlToHttpOptions' is defined but never used.","'fs' is defined but never used.","'path' is defined but never used.","'useState' is defined but never used.","'FlashCard' is defined but never used.","'cardEquality' is defined but never used.","'ImportCard' is defined but never used.","'ChangeEvent' is defined but never used.","'PropsWithChildren' is defined but never used.","'ReactElement' is defined but never used.","'useCallback' is defined but never used.","'exportCards' is defined but never used.","'Form' is defined but never used."]