{"ast":null,"code":"import { urlToHttpOptions } from \"url\";\n// import { Card } from \"./interfaces/card\";\nimport * as path from \"path\";\nimport { equal } from \"assert\";\nimport { cardEquality, arrayEquality, exportPath, deckEquality, stringToCard } from \"./utils\";\n// const fs = require('fs');\n\n// File management from tutorial: https://iq.opengenus.org/create-delete-files-directory-js/\n/***\nGoes over all cards in the users collection and exports them to a formatted txt file. \nThe user must provide a file name for the exported file.\nIf deckID is non-empty, then only cards included in the specified deck will be exported.\nReturns true on success and false on a failure\n */\n// export function exportCards(\n//     cards,\n//     fileName,\n//     deckID = \"\"\n// ) {\n//     if (!fs.existsSync(exportPath)){\n//         fs.mkdirSync(exportPath);\n//     }\n//     if (cards.length === 0) {\n//         return false;\n//     }\n//     else if (deckID !== \"\"){\n//         cards = cards.filter((card) => card.cardDecks.includes(deckID))\n//         if (cards.length === 0) {\n//             return false;\n//         }    \n//     }\n//     let cardString = \"\";\n//     let cardArray = [];\n//     cards.map((card) => \n//         // Results in growing string[] array where each string represents an array containing the data for one card object\n//         // There are separate delimiters from join() between the properties of a given card (<|>) and between each card (<|||>)\n//         // This way an array-of-arrays can be retrieved by a 2-step split() call and subsequently mapped over to recreate the cards.\n//         cardArray = [...cardArray, [card.cardColor , card.frontText , card.backText , card.cardHint, card.cardDecks.join(\",\"), String(card.accuracy)].join(\"<|>\")],\n//         );\n\n//     cardString = cardArray.join(\"<|||>\")\n//     // console.log(\"cardString is: \" + cardString + \"\\n\");\n\n//     fs.writeFileSync((exportPath + fileName), cardString);\n\n//     // fs.writeFileSync((exportPath + \"copyFile2.txt\"), cardString);\n//     // fs.unlinkSync((exportPath + \"mytext.txt\"));\n//     return true;\n// }\n\n// File management from tutorial: https://iq.opengenus.org/create-delete-files-directory-js/\n/***\nGoes over all cards in the users collection and exports them to a formatted txt file. \nThe user must provide a file name for the exported file.\nIf deckID is non-empty, then only cards included in the specified deck will be exported.\nReturns true on success and false on a failure\n */\nexport function parseCardsToString(cards) {\n  let deckID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  // console.log(cards.length);\n  if (cards.length === 0) {\n    return \"\";\n  } else if (deckID !== \"\") {\n    cards = cards.filter(card => card.cardDecks.includes(deckID));\n    if (cards.length === 0) {\n      return \"\";\n    }\n  }\n  let cardString = \"\";\n  let cardArray = [];\n  cards.map(card =>\n  // Results in growing string[] array where each string represents an array containing the data for one card object\n  // There are separate delimiters from join() between the properties of a given card (<|>) and between each card (<|||>)\n  // This way an array-of-arrays can be retrieved by a 2-step split() call and subsequently mapped over to recreate the cards.\n  cardArray = [...cardArray, [card.cardColor, card.frontText, card.backText, card.cardHint, card.cardDecks.join(\",\"), String(card.accuracy)].join(\"<|>\")]);\n  cardString = cardArray.join(\"<|||>\");\n  // console.log(cardString);\n  return cardString;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * If deckName is specified, cards will only be added to the specified deck\n */\n//  export function loadCardsFromTxt(\n//     filePath,\n//     deckName = \"\"\n// ) {\n//     const textFileString = fs.readFileSync(filePath).toString();\n//     const importedIntermediateData = textFileString.split(\"<|||>\")\n//     const importedCards = importedIntermediateData.map((cardString) =>\n//         stringToCard(cardString)\n//     )\n//     return importedCards;\n// }\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * If deckName is specified, cards will only be added to the specified deck\n */\nexport function loadCardsFromString(inputText) {\n  let deckName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  const importedIntermediateData = inputText.split(\"<|||>\");\n  const importedCards = importedIntermediateData.map(cardString => stringToCard(cardString));\n  return importedCards;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * Missing Functionality: Once integrated with React UI:\n *       If deckName is specified, cards will be added to the specified deck\n */\n//  export function importCards(\n//     filePath,\n//     collection,\n//     deckName = \"\"\n// ) {\n//     let maxId = -1;\n//     collection.map((card) => {\n//         if (card.id > maxId){maxId = card.id}\n//     })\n//     const importedCards = loadCardsFromTxt(filePath, deckName)\n//     importedCards.map((card) => {\n//         let duplicate = false;\n//         if ( collection.length !== 0 ){\n//             collection.map((collectionCard) => {\n//                 if (cardEquality(collectionCard, card)) {\n//                     duplicate = true;\n//                 }\n//             })\n//             if (duplicate === false){\n//                 maxId = maxId + 1\n//                 collection = [...collection, { \n//                     id: maxId, \n//                     cardColor: card.cardColor, \n//                     frontText: card.frontText, \n//                     backText: card.backText, \n//                     cardHint: card.cardHint, \n//                     cardDecks: card.cardDecks, \n//                     accuracy: card.accuracy }]\n//             }\n//         }\n//         else {\n//             maxId = maxId + 1\n//             collection = [{ \n//                 id: maxId, \n//                 cardColor: card.cardColor, \n//                 frontText: card.frontText, \n//                 backText: card.backText, \n//                 cardHint: card.cardHint, \n//                 cardDecks: card.cardDecks, \n//                 accuracy: card.accuracy }]\n//         }\n//     })\n//     return collection;\n// }\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * Missing Functionality: Once integrated with React UI:\n *       If deckName is specified, cards will be added to the specified deck\n */\nexport function parseInputs(inputText, collection) {\n  let deckName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  let maxId = -1;\n  collection.map(card => {\n    if (card.id > maxId) {\n      maxId = card.id;\n    }\n  });\n  const importedCards = loadCardsFromString(inputText, deckName);\n  importedCards.map(card => {\n    let duplicate = false;\n    if (collection.length !== 0) {\n      collection.map(collectionCard => {\n        if (cardEquality(collectionCard, card)) {\n          duplicate = true;\n        }\n      });\n      if (duplicate === false) {\n        maxId = maxId + 1;\n        collection = [...collection, {\n          id: maxId,\n          cardColor: card.cardColor,\n          frontText: card.frontText,\n          backText: card.backText,\n          cardHint: card.cardHint,\n          cardDecks: card.cardDecks,\n          accuracy: card.accuracy\n        }];\n      }\n    } else {\n      maxId = maxId + 1;\n      collection = [{\n        id: maxId,\n        cardColor: card.cardColor,\n        frontText: card.frontText,\n        backText: card.backText,\n        cardHint: card.cardHint,\n        cardDecks: card.cardDecks,\n        accuracy: card.accuracy\n      }];\n    }\n  });\n  return collection;\n}","map":{"version":3,"names":["urlToHttpOptions","path","equal","cardEquality","arrayEquality","exportPath","deckEquality","stringToCard","parseCardsToString","cards","deckID","length","filter","card","cardDecks","includes","cardString","cardArray","map","cardColor","frontText","backText","cardHint","join","String","accuracy","loadCardsFromString","inputText","deckName","importedIntermediateData","split","importedCards","parseInputs","collection","maxId","id","duplicate","collectionCard"],"sources":["/home/josh/Desktop/COS520/IntegratedJS/TeamC/memento-with-react/src/importExport.js"],"sourcesContent":["import { urlToHttpOptions } from \"url\";\n// import { Card } from \"./interfaces/card\";\nimport * as path from \"path\";\nimport { equal } from \"assert\";\nimport { cardEquality, arrayEquality, exportPath, deckEquality, stringToCard } from \"./utils\";\n// const fs = require('fs');\n\n\n\n// File management from tutorial: https://iq.opengenus.org/create-delete-files-directory-js/\n/***\nGoes over all cards in the users collection and exports them to a formatted txt file. \nThe user must provide a file name for the exported file.\nIf deckID is non-empty, then only cards included in the specified deck will be exported.\nReturns true on success and false on a failure\n */\n// export function exportCards(\n//     cards,\n//     fileName,\n//     deckID = \"\"\n// ) {\n//     if (!fs.existsSync(exportPath)){\n//         fs.mkdirSync(exportPath);\n//     }\n//     if (cards.length === 0) {\n//         return false;\n//     }\n//     else if (deckID !== \"\"){\n//         cards = cards.filter((card) => card.cardDecks.includes(deckID))\n//         if (cards.length === 0) {\n//             return false;\n//         }    \n//     }\n//     let cardString = \"\";\n//     let cardArray = [];\n//     cards.map((card) => \n//         // Results in growing string[] array where each string represents an array containing the data for one card object\n//         // There are separate delimiters from join() between the properties of a given card (<|>) and between each card (<|||>)\n//         // This way an array-of-arrays can be retrieved by a 2-step split() call and subsequently mapped over to recreate the cards.\n//         cardArray = [...cardArray, [card.cardColor , card.frontText , card.backText , card.cardHint, card.cardDecks.join(\",\"), String(card.accuracy)].join(\"<|>\")],\n//         );\n\n//     cardString = cardArray.join(\"<|||>\")\n//     // console.log(\"cardString is: \" + cardString + \"\\n\");\n\n//     fs.writeFileSync((exportPath + fileName), cardString);\n \n//     // fs.writeFileSync((exportPath + \"copyFile2.txt\"), cardString);\n//     // fs.unlinkSync((exportPath + \"mytext.txt\"));\n//     return true;\n// }\n\n\n// File management from tutorial: https://iq.opengenus.org/create-delete-files-directory-js/\n/***\nGoes over all cards in the users collection and exports them to a formatted txt file. \nThe user must provide a file name for the exported file.\nIf deckID is non-empty, then only cards included in the specified deck will be exported.\nReturns true on success and false on a failure\n */\nexport function parseCardsToString(\n    cards,\n    deckID = \"\"\n) {\n    // console.log(cards.length);\n    if (cards.length === 0) {\n        return \"\";\n    }\n    else if (deckID !== \"\"){\n        cards = cards.filter((card) => card.cardDecks.includes(deckID))\n        if (cards.length === 0) {\n            return \"\";\n        }    \n    }\n    let cardString = \"\";\n    let cardArray = [];\n    cards.map((card) => \n        // Results in growing string[] array where each string represents an array containing the data for one card object\n        // There are separate delimiters from join() between the properties of a given card (<|>) and between each card (<|||>)\n        // This way an array-of-arrays can be retrieved by a 2-step split() call and subsequently mapped over to recreate the cards.\n        cardArray = [...cardArray, [card.cardColor , card.frontText , card.backText , card.cardHint, card.cardDecks.join(\",\"), String(card.accuracy)].join(\"<|>\")],\n        );\n    cardString = cardArray.join(\"<|||>\");\n    // console.log(cardString);\n    return cardString;\n}\n\n\n\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * If deckName is specified, cards will only be added to the specified deck\n */\n//  export function loadCardsFromTxt(\n//     filePath,\n//     deckName = \"\"\n// ) {\n//     const textFileString = fs.readFileSync(filePath).toString();\n//     const importedIntermediateData = textFileString.split(\"<|||>\")\n//     const importedCards = importedIntermediateData.map((cardString) =>\n//         stringToCard(cardString)\n//     )\n//     return importedCards;\n// }\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * If deckName is specified, cards will only be added to the specified deck\n */\n export function loadCardsFromString(\n    inputText,\n    deckName = \"\"\n) {\n    const importedIntermediateData = inputText.split(\"<|||>\")\n    const importedCards = importedIntermediateData.map((cardString) =>\n        stringToCard(cardString)\n    )\n    return importedCards;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * Missing Functionality: Once integrated with React UI:\n *       If deckName is specified, cards will be added to the specified deck\n */\n//  export function importCards(\n//     filePath,\n//     collection,\n//     deckName = \"\"\n// ) {\n//     let maxId = -1;\n//     collection.map((card) => {\n//         if (card.id > maxId){maxId = card.id}\n//     })\n//     const importedCards = loadCardsFromTxt(filePath, deckName)\n//     importedCards.map((card) => {\n//         let duplicate = false;\n//         if ( collection.length !== 0 ){\n//             collection.map((collectionCard) => {\n//                 if (cardEquality(collectionCard, card)) {\n//                     duplicate = true;\n//                 }\n//             })\n//             if (duplicate === false){\n//                 maxId = maxId + 1\n//                 collection = [...collection, { \n//                     id: maxId, \n//                     cardColor: card.cardColor, \n//                     frontText: card.frontText, \n//                     backText: card.backText, \n//                     cardHint: card.cardHint, \n//                     cardDecks: card.cardDecks, \n//                     accuracy: card.accuracy }]\n//             }\n//         }\n//         else {\n//             maxId = maxId + 1\n//             collection = [{ \n//                 id: maxId, \n//                 cardColor: card.cardColor, \n//                 frontText: card.frontText, \n//                 backText: card.backText, \n//                 cardHint: card.cardHint, \n//                 cardDecks: card.cardDecks, \n//                 accuracy: card.accuracy }]\n//         }\n//     })\n//     return collection;\n// }\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * Missing Functionality: Once integrated with React UI:\n *       If deckName is specified, cards will be added to the specified deck\n */\n export function parseInputs(\n    inputText,\n    collection,\n    deckName = \"\"\n) {\n    let maxId = -1;\n    collection.map((card) => {\n        if (card.id > maxId){maxId = card.id}\n    })\n    const importedCards = loadCardsFromString(inputText, deckName)\n    importedCards.map((card) => {\n        let duplicate = false;\n        if ( collection.length !== 0 ){\n            collection.map((collectionCard) => {\n                if (cardEquality(collectionCard, card)) {\n                    duplicate = true;\n                }\n            })\n            if (duplicate === false){\n                maxId = maxId + 1\n                collection = [...collection, { \n                    id: maxId, \n                    cardColor: card.cardColor, \n                    frontText: card.frontText, \n                    backText: card.backText, \n                    cardHint: card.cardHint, \n                    cardDecks: card.cardDecks, \n                    accuracy: card.accuracy }]\n            }\n        }\n        else {\n            maxId = maxId + 1\n            collection = [{ \n                id: maxId, \n                cardColor: card.cardColor, \n                frontText: card.frontText, \n                backText: card.backText, \n                cardHint: card.cardHint, \n                cardDecks: card.cardDecks, \n                accuracy: card.accuracy }]\n        }\n    })\n    return collection;\n}\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}