{"ast":null,"code":"import { urlToHttpOptions } from \"url\";\n// import { Card } from \"./interfaces/card\";\nimport * as path from \"path\";\nimport { equal } from \"assert\";\nimport { cardEquality, arrayEquality, exportPath, deckEquality, stringToCard } from \"./utils\";\nconst fs = require('fs');\n\n// File management from tutorial: https://iq.opengenus.org/create-delete-files-directory-js/\n/***\nGoes over all cards in the users collection and exports them to a formatted txt file. \nThe user must provide a file name for the exported file.\nIf deckID is non-empty, then only cards included in the specified deck will be exported.\nReturns true on success and false on a failure\n */\nexport function exportCards(cards, fileName) {\n  let deckID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  if (!fs.existsSync(exportPath)) {\n    fs.mkdirSync(exportPath);\n  }\n  if (cards.length === 0) {\n    return false;\n  } else if (deckID !== \"\") {\n    cards = cards.filter(card => card.cardDecks.includes(deckID));\n    if (cards.length === 0) {\n      return false;\n    }\n  }\n  let cardString = \"\";\n  let cardArray = [];\n  cards.map(card =>\n  // Results in growing string[] array where each string represents an array containing the data for one card object\n  // There are separate delimiters from join() between the properties of a given card (<|>) and between each card (<|||>)\n  // This way an array-of-arrays can be retrieved by a 2-step split() call and subsequently mapped over to recreate the cards.\n  cardArray = [...cardArray, [card.cardColor, card.frontText, card.backText, card.cardHint, card.cardDecks.join(\",\"), String(card.accuracy)].join(\"<|>\")]);\n  cardString = cardArray.join(\"<|||>\");\n  // console.log(\"cardString is: \" + cardString + \"\\n\");\n\n  fs.writeFileSync(exportPath + fileName, cardString);\n\n  // fs.writeFileSync((exportPath + \"copyFile2.txt\"), cardString);\n  // fs.unlinkSync((exportPath + \"mytext.txt\"));\n  return true;\n}\n\n// File management from tutorial: https://iq.opengenus.org/create-delete-files-directory-js/\n/***\nGoes over all cards in the users collection and exports them to a formatted txt file. \nThe user must provide a file name for the exported file.\nIf deckID is non-empty, then only cards included in the specified deck will be exported.\nReturns true on success and false on a failure\n */\nexport function parseCardsToString(cards) {\n  let deckID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  // console.log(cards.length);\n  if (cards.length === 0) {\n    return \"\";\n  } else if (deckID !== \"\") {\n    cards = cards.filter(card => card.cardDecks.includes(deckID));\n    if (cards.length === 0) {\n      return \"\";\n    }\n  }\n  let cardString = \"\";\n  let cardArray = [];\n  cards.map(card =>\n  // Results in growing string[] array where each string represents an array containing the data for one card object\n  // There are separate delimiters from join() between the properties of a given card (<|>) and between each card (<|||>)\n  // This way an array-of-arrays can be retrieved by a 2-step split() call and subsequently mapped over to recreate the cards.\n  cardArray = [...cardArray, [card.cardColor, card.frontText, card.backText, card.cardHint, card.cardDecks.join(\",\"), String(card.accuracy)].join(\"<|>\")]);\n  cardString = cardArray.join(\"<|||>\");\n  // console.log(cardString);\n  return cardString;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * If deckName is specified, cards will only be added to the specified deck\n */\nexport function loadCardsFromTxt(filePath) {\n  let deckName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  const textFileString = fs.readFileSync(filePath).toString();\n  const importedIntermediateData = textFileString.split(\"<|||>\");\n  const importedCards = importedIntermediateData.map(cardString => stringToCard(cardString));\n  return importedCards;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * If deckName is specified, cards will only be added to the specified deck\n */\nexport function loadCardsFromString(inputText) {\n  let deckName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  const importedIntermediateData = inputText.split(\"<|||>\");\n  const importedCards = importedIntermediateData.map(cardString => stringToCard(cardString));\n  return importedCards;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * Missing Functionality: Once integrated with React UI:\n *       If deckName is specified, cards will be added to the specified deck\n */\nexport function importCards(filePath, collection) {\n  let deckName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  let maxId = -1;\n  collection.map(card => {\n    if (card.id > maxId) {\n      maxId = card.id;\n    }\n  });\n  const importedCards = loadCardsFromTxt(filePath, deckName);\n  importedCards.map(card => {\n    let duplicate = false;\n    if (collection.length !== 0) {\n      collection.map(collectionCard => {\n        if (cardEquality(collectionCard, card)) {\n          duplicate = true;\n        }\n      });\n      if (duplicate === false) {\n        maxId = maxId + 1;\n        collection = [...collection, {\n          id: maxId,\n          cardColor: card.cardColor,\n          frontText: card.frontText,\n          backText: card.backText,\n          cardHint: card.cardHint,\n          cardDecks: card.cardDecks,\n          accuracy: card.accuracy\n        }];\n      }\n    } else {\n      maxId = maxId + 1;\n      collection = [{\n        id: maxId,\n        cardColor: card.cardColor,\n        frontText: card.frontText,\n        backText: card.backText,\n        cardHint: card.cardHint,\n        cardDecks: card.cardDecks,\n        accuracy: card.accuracy\n      }];\n    }\n  });\n  return collection;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * Missing Functionality: Once integrated with React UI:\n *       If deckName is specified, cards will be added to the specified deck\n */\nexport function parseInputs(inputText, collection) {\n  let deckName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  let maxId = -1;\n  collection.map(card => {\n    if (card.id > maxId) {\n      maxId = card.id;\n    }\n  });\n  const importedCards = loadCardsFromString(inputText, deckName);\n  importedCards.map(card => {\n    let duplicate = false;\n    if (collection.length !== 0) {\n      collection.map(collectionCard => {\n        if (cardEquality(collectionCard, card)) {\n          duplicate = true;\n        }\n      });\n      if (duplicate === false) {\n        maxId = maxId + 1;\n        collection = [...collection, {\n          id: maxId,\n          cardColor: card.cardColor,\n          frontText: card.frontText,\n          backText: card.backText,\n          cardHint: card.cardHint,\n          cardDecks: card.cardDecks,\n          accuracy: card.accuracy\n        }];\n      }\n    } else {\n      maxId = maxId + 1;\n      collection = [{\n        id: maxId,\n        cardColor: card.cardColor,\n        frontText: card.frontText,\n        backText: card.backText,\n        cardHint: card.cardHint,\n        cardDecks: card.cardDecks,\n        accuracy: card.accuracy\n      }];\n    }\n  });\n  return collection;\n}","map":{"version":3,"names":["urlToHttpOptions","path","equal","cardEquality","arrayEquality","exportPath","deckEquality","stringToCard","fs","require","exportCards","cards","fileName","deckID","existsSync","mkdirSync","length","filter","card","cardDecks","includes","cardString","cardArray","map","cardColor","frontText","backText","cardHint","join","String","accuracy","writeFileSync","parseCardsToString","loadCardsFromTxt","filePath","deckName","textFileString","readFileSync","toString","importedIntermediateData","split","importedCards","loadCardsFromString","inputText","importCards","collection","maxId","id","duplicate","collectionCard","parseInputs"],"sources":["/home/josh/Desktop/COS520/IntegratedJS/TeamC/memento-with-react/src/importExport.js"],"sourcesContent":["import { urlToHttpOptions } from \"url\";\n// import { Card } from \"./interfaces/card\";\nimport * as path from \"path\";\nimport { equal } from \"assert\";\nimport { cardEquality, arrayEquality, exportPath, deckEquality, stringToCard } from \"./utils\";\nconst fs = require('fs');\n\n\n\n// File management from tutorial: https://iq.opengenus.org/create-delete-files-directory-js/\n/***\nGoes over all cards in the users collection and exports them to a formatted txt file. \nThe user must provide a file name for the exported file.\nIf deckID is non-empty, then only cards included in the specified deck will be exported.\nReturns true on success and false on a failure\n */\nexport function exportCards(\n    cards,\n    fileName,\n    deckID = \"\"\n) {\n    if (!fs.existsSync(exportPath)){\n        fs.mkdirSync(exportPath);\n    }\n    if (cards.length === 0) {\n        return false;\n    }\n    else if (deckID !== \"\"){\n        cards = cards.filter((card) => card.cardDecks.includes(deckID))\n        if (cards.length === 0) {\n            return false;\n        }    \n    }\n    let cardString = \"\";\n    let cardArray = [];\n    cards.map((card) => \n        // Results in growing string[] array where each string represents an array containing the data for one card object\n        // There are separate delimiters from join() between the properties of a given card (<|>) and between each card (<|||>)\n        // This way an array-of-arrays can be retrieved by a 2-step split() call and subsequently mapped over to recreate the cards.\n        cardArray = [...cardArray, [card.cardColor , card.frontText , card.backText , card.cardHint, card.cardDecks.join(\",\"), String(card.accuracy)].join(\"<|>\")],\n        );\n\n    cardString = cardArray.join(\"<|||>\")\n    // console.log(\"cardString is: \" + cardString + \"\\n\");\n\n    fs.writeFileSync((exportPath + fileName), cardString);\n \n    // fs.writeFileSync((exportPath + \"copyFile2.txt\"), cardString);\n    // fs.unlinkSync((exportPath + \"mytext.txt\"));\n    return true;\n}\n\n\n// File management from tutorial: https://iq.opengenus.org/create-delete-files-directory-js/\n/***\nGoes over all cards in the users collection and exports them to a formatted txt file. \nThe user must provide a file name for the exported file.\nIf deckID is non-empty, then only cards included in the specified deck will be exported.\nReturns true on success and false on a failure\n */\nexport function parseCardsToString(\n    cards,\n    deckID = \"\"\n) {\n    // console.log(cards.length);\n    if (cards.length === 0) {\n        return \"\";\n    }\n    else if (deckID !== \"\"){\n        cards = cards.filter((card) => card.cardDecks.includes(deckID))\n        if (cards.length === 0) {\n            return \"\";\n        }    \n    }\n    let cardString = \"\";\n    let cardArray = [];\n    cards.map((card) => \n        // Results in growing string[] array where each string represents an array containing the data for one card object\n        // There are separate delimiters from join() between the properties of a given card (<|>) and between each card (<|||>)\n        // This way an array-of-arrays can be retrieved by a 2-step split() call and subsequently mapped over to recreate the cards.\n        cardArray = [...cardArray, [card.cardColor , card.frontText , card.backText , card.cardHint, card.cardDecks.join(\",\"), String(card.accuracy)].join(\"<|>\")],\n        );\n    cardString = cardArray.join(\"<|||>\");\n    // console.log(cardString);\n    return cardString;\n}\n\n\n\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * If deckName is specified, cards will only be added to the specified deck\n */\n export function loadCardsFromTxt(\n    filePath,\n    deckName = \"\"\n) {\n    const textFileString = fs.readFileSync(filePath).toString();\n    const importedIntermediateData = textFileString.split(\"<|||>\")\n    const importedCards = importedIntermediateData.map((cardString) =>\n        stringToCard(cardString)\n    )\n    return importedCards;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * If deckName is specified, cards will only be added to the specified deck\n */\n export function loadCardsFromString(\n    inputText,\n    deckName = \"\"\n) {\n    const importedIntermediateData = inputText.split(\"<|||>\")\n    const importedCards = importedIntermediateData.map((cardString) =>\n        stringToCard(cardString)\n    )\n    return importedCards;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * Missing Functionality: Once integrated with React UI:\n *       If deckName is specified, cards will be added to the specified deck\n */\n export function importCards(\n    filePath,\n    collection,\n    deckName = \"\"\n) {\n    let maxId = -1;\n    collection.map((card) => {\n        if (card.id > maxId){maxId = card.id}\n    })\n    const importedCards = loadCardsFromTxt(filePath, deckName)\n    importedCards.map((card) => {\n        let duplicate = false;\n        if ( collection.length !== 0 ){\n            collection.map((collectionCard) => {\n                if (cardEquality(collectionCard, card)) {\n                    duplicate = true;\n                }\n            })\n            if (duplicate === false){\n                maxId = maxId + 1\n                collection = [...collection, { \n                    id: maxId, \n                    cardColor: card.cardColor, \n                    frontText: card.frontText, \n                    backText: card.backText, \n                    cardHint: card.cardHint, \n                    cardDecks: card.cardDecks, \n                    accuracy: card.accuracy }]\n            }\n        }\n        else {\n            maxId = maxId + 1\n            collection = [{ \n                id: maxId, \n                cardColor: card.cardColor, \n                frontText: card.frontText, \n                backText: card.backText, \n                cardHint: card.cardHint, \n                cardDecks: card.cardDecks, \n                accuracy: card.accuracy }]\n        }\n    })\n    return collection;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * Missing Functionality: Once integrated with React UI:\n *       If deckName is specified, cards will be added to the specified deck\n */\n export function parseInputs(\n    inputText,\n    collection,\n    deckName = \"\"\n) {\n    let maxId = -1;\n    collection.map((card) => {\n        if (card.id > maxId){maxId = card.id}\n    })\n    const importedCards = loadCardsFromString(inputText, deckName)\n    importedCards.map((card) => {\n        let duplicate = false;\n        if ( collection.length !== 0 ){\n            collection.map((collectionCard) => {\n                if (cardEquality(collectionCard, card)) {\n                    duplicate = true;\n                }\n            })\n            if (duplicate === false){\n                maxId = maxId + 1\n                collection = [...collection, { \n                    id: maxId, \n                    cardColor: card.cardColor, \n                    frontText: card.frontText, \n                    backText: card.backText, \n                    cardHint: card.cardHint, \n                    cardDecks: card.cardDecks, \n                    accuracy: card.accuracy }]\n            }\n        }\n        else {\n            maxId = maxId + 1\n            collection = [{ \n                id: maxId, \n                cardColor: card.cardColor, \n                frontText: card.frontText, \n                backText: card.backText, \n                cardHint: card.cardHint, \n                cardDecks: card.cardDecks, \n                accuracy: card.accuracy }]\n        }\n    })\n    return collection;\n}\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}