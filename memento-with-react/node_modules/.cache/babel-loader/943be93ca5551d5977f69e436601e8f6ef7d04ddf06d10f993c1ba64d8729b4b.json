{"ast":null,"code":"import * as fs from \"fs\";\nimport { cardEquality, exportPath, stringToCard } from \"./utils\";\n\n// File management from tutorial: https://iq.opengenus.org/create-delete-files-directory-js/\n/***\nGoes over all cards in the users collection and exports them to a formatted txt file. \nThe user must provide a file name for the exported file.\nIf deckID is non-empty, then only cards included in the specified deck will be exported.\nReturns true on success and false on a failure\n */\nexport function exportCards(cards, fileName) {\n  let deckID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  if (!fs.existsSync(exportPath)) {\n    fs.mkdirSync(exportPath);\n  }\n  if (cards.length === 0) {\n    return false;\n  } else if (deckID !== \"\") {\n    cards = cards.filter(card => card.cardDecks.includes(deckID));\n    if (cards.length === 0) {\n      return false;\n    }\n  }\n  let cardString = \"\";\n  let cardArray = [];\n  cards.map(card =>\n  // Results in growing string[] array where each string represents an array containing the data for one card object\n  // There are separate delimiters from join() between the properties of a given card (<|>) and between each card (<|||>)\n  // This way an array-of-arrays can be retrieved by a 2-step split() call and subsequently mapped over to recreate the cards.\n  cardArray = [...cardArray, [card.cardColor, card.frontText, card.backText, card.cardHint, card.cardDecks.join(\",\"), String(card.accuracy)].join(\"<|>\")]);\n  cardString = cardArray.join(\"<|||>\");\n  // console.log(\"cardString is: \" + cardString + \"\\n\");\n\n  fs.writeFileSync(exportPath + fileName, cardString);\n\n  // fs.writeFileSync((exportPath + \"copyFile2.txt\"), cardString);\n  // fs.unlinkSync((exportPath + \"mytext.txt\"));\n  return true;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * If deckName is specified, cards will only be added to the specified deck\n */\nexport function loadCardsFromTxt(filePath) {\n  let deckName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  const textFileString = fs.readFileSync(filePath).toString();\n  const importedIntermediateData = textFileString.split(\"<|||>\");\n  const importedCards = importedIntermediateData.map(cardString => stringToCard(cardString));\n  return importedCards;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * Missing Functionality: Once integrated with React UI:\n *       If deckName is specified, cards will be added to the specified deck\n */\nexport function importCards(filePath, collection) {\n  let deckName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  let maxId = -1;\n  collection.map(card => {\n    if (card.id > maxId) {\n      maxId = card.id;\n    }\n  });\n  const importedCards = loadCardsFromTxt(filePath, deckName);\n  importedCards.map(card => {\n    let duplicate = false;\n    if (collection.length !== 0) {\n      collection.map(collectionCard => {\n        if (cardEquality(collectionCard, card)) {\n          duplicate = true;\n        }\n      });\n      if (duplicate === false) {\n        maxId = maxId + 1;\n        collection = [...collection, {\n          id: maxId,\n          cardColor: card.cardColor,\n          frontText: card.frontText,\n          backText: card.backText,\n          cardHint: card.cardHint,\n          cardDecks: card.cardDecks,\n          accuracy: card.accuracy\n        }];\n      }\n    } else {\n      maxId = maxId + 1;\n      collection = [{\n        id: maxId,\n        cardColor: card.cardColor,\n        frontText: card.frontText,\n        backText: card.backText,\n        cardHint: card.cardHint,\n        cardDecks: card.cardDecks,\n        accuracy: card.accuracy\n      }];\n    }\n  });\n  return collection;\n}","map":{"version":3,"names":["fs","cardEquality","exportPath","stringToCard","exportCards","cards","fileName","deckID","existsSync","mkdirSync","length","filter","card","cardDecks","includes","cardString","cardArray","map","cardColor","frontText","backText","cardHint","join","String","accuracy","writeFileSync","loadCardsFromTxt","filePath","deckName","textFileString","readFileSync","toString","importedIntermediateData","split","importedCards","importCards","collection","maxId","id","duplicate","collectionCard"],"sources":["/home/josh/Desktop/COS520/Mem/TeamC/memento-with-react/src/importExport.ts"],"sourcesContent":["import { urlToHttpOptions } from \"url\";\nimport { Card } from \"./interfaces/card\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { equal } from \"assert\";\nimport { cardEquality, arrayEquality, exportPath, deckEquality, stringToCard } from \"./utils\";\n\n\n\n// File management from tutorial: https://iq.opengenus.org/create-delete-files-directory-js/\n/***\nGoes over all cards in the users collection and exports them to a formatted txt file. \nThe user must provide a file name for the exported file.\nIf deckID is non-empty, then only cards included in the specified deck will be exported.\nReturns true on success and false on a failure\n */\nexport function exportCards(\n    cards: Card[],\n    fileName: string,\n    deckID: string = \"\"\n): boolean {\n    if (!fs.existsSync(exportPath)){\n        fs.mkdirSync(exportPath);\n    }\n    if (cards.length === 0) {\n        return false;\n    }\n    else if (deckID !== \"\"){\n        cards = cards.filter((card: Card): boolean => card.cardDecks.includes(deckID))\n        if (cards.length === 0) {\n            return false;\n        }    \n    }\n    let cardString: string = \"\";\n    let cardArray: string[] = [];\n    cards.map((card: Card): string[] => \n        // Results in growing string[] array where each string represents an array containing the data for one card object\n        // There are separate delimiters from join() between the properties of a given card (<|>) and between each card (<|||>)\n        // This way an array-of-arrays can be retrieved by a 2-step split() call and subsequently mapped over to recreate the cards.\n        cardArray = [...cardArray, [card.cardColor , card.frontText , card.backText , card.cardHint, card.cardDecks.join(\",\"), String(card.accuracy)].join(\"<|>\")],\n        );\n\n    cardString = cardArray.join(\"<|||>\")\n    // console.log(\"cardString is: \" + cardString + \"\\n\");\n\n    fs.writeFileSync((exportPath + fileName), cardString);\n \n    // fs.writeFileSync((exportPath + \"copyFile2.txt\"), cardString);\n    // fs.unlinkSync((exportPath + \"mytext.txt\"));\n    return true;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * If deckName is specified, cards will only be added to the specified deck\n */\n export function loadCardsFromTxt(\n    filePath: string,\n    deckName: string = \"\"\n): Card[] {\n    const textFileString: string = fs.readFileSync(filePath).toString();\n    const importedIntermediateData: string[] = textFileString.split(\"<|||>\")\n    const importedCards: Card[] = importedIntermediateData.map((cardString: string): Card =>\n        stringToCard(cardString)\n    )\n    return importedCards;\n}\n\n/***\n * import cards from a given txt file path, returns the array of imported cards.\n * Missing Functionality: Once integrated with React UI:\n *       If deckName is specified, cards will be added to the specified deck\n */\n export function importCards(\n    filePath: string,\n    collection: Card[],\n    deckName: string = \"\"\n): Card[] {\n    let maxId = -1;\n    collection.map((card: Card): void => {\n        if (card.id > maxId){maxId = card.id}\n    })\n    const importedCards: Card[] = loadCardsFromTxt(filePath, deckName)\n    importedCards.map((card: Card): void => {\n        let duplicate: boolean = false;\n        if ( collection.length !== 0 ){\n            collection.map((collectionCard: Card): void => {\n                if (cardEquality(collectionCard, card)) {\n                    duplicate = true;\n                }\n            })\n            if (duplicate === false){\n                maxId = maxId + 1\n                collection = [...collection, { \n                    id: maxId, \n                    cardColor: card.cardColor, \n                    frontText: card.frontText, \n                    backText: card.backText, \n                    cardHint: card.cardHint, \n                    cardDecks: card.cardDecks, \n                    accuracy: card.accuracy }]\n            }\n        }\n        else {\n            maxId = maxId + 1\n            collection = [{ \n                id: maxId, \n                cardColor: card.cardColor, \n                frontText: card.frontText, \n                backText: card.backText, \n                cardHint: card.cardHint, \n                cardDecks: card.cardDecks, \n                accuracy: card.accuracy }]\n        }\n    })\n    return collection;\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}